# encryption

A wrapper around `crypto.subtle` with a simple API which the following features:
- derive a key from a password with PBKDF2
- or generate a single use random key
- encrypt text with AES in Galois/Counter Mode.

Deriving a key requires a salt, which must be saved somewhere safe in order to be able to regenerate the same key from the same password.

AES-GCM uses an initialization vector (iv) to randomise the encryption. Each encrypted message can and must be stored along with its associated iv.

## How to install

```
npm install --save-dev https://github.com/geoffreyTools/encryption.git
```

## How to use

```javascript
import encryption, { generateSalt } from 'encryption';

const password = '2@4ZNyxSijhUXYrQ';
const salt = generateSalt();

const { encrypt, decrypt } = encryption(password, salt);

const log = x => (console.log(x), x);

encrypt('message')
    .then(log) // { cipher: 'Nu/mxRj0GArC7NVCNHqcR7CnBS6iDBc=', iv: 'Nw/4KTuLGCiCHbnU' }
    .then(decrypt);
    .then(log) // 'message'
```

## generateSalt
### Syntax
```
const salt = generateSalt();
```
### Return value

- `salt`: a bas64 String.
## encryption
### Syntax
```
const { encrypt, decrypt } = encryption();
const { encrypt, decrypt } = encryption(password, salt);
```
### Parameters
- `password` (optional): a plain text password
- `salt` (optional): a base64 String as generated by `generateSalt`.

The salt is required for persistance if you supply a password.
### Return value
- `{ encrypt, decrypt}`
```
const encrypted = encrypt(message);
```
`encrypt`: a function seeded with the encryption key which accepts a String to encrypt and returns a `Promise` of a `{cipher, iv}` pair (which are base64 encoded Strings).
```
const decrypted = decrypt({ cipher, iv });
```
`decrypt`: a function seeded with the encryption key which returns a `Promise` of a String.